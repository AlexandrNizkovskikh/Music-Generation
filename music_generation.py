# -*- coding: utf-8 -*-
"""Music_generation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fo2f0b79B6AOIvrc54rcpWKoQCVy3AVj

# Введение:
Этот проект посвящен созданию нейросетевой модели для генерации классической музыки.

В процессе работы используются MIDI файлы известных композиторов, которые анализируются, а затем на их основе создается новая музыкальная композиция с использованием LSTM модели.

Основная цель проекта — исследовать возможности машинного обучения в области музыкальной генерации.

# Установка и импорт необходимых библиотек
"""

# Установка библиотеки music21 для работы с MIDI файлами
!pip install --upgrade music21  # Анализ и парсинг MIDI файлов

# Установка FluidSynth для синтеза аудио из MIDI
!sudo apt install -y fluidsynth  # Синтезатор для воспроизведения MIDI

# Установка PyFluidSynth для взаимодействия с FluidSynth из Python
!pip install --upgrade pyfluidsynth  # Python-обертка для FluidSynth

# Добавление PPA для установки MuseScore
!add-apt-repository ppa:mscore-ubuntu/mscore-stable -y  # PPA (Personal Package Archive) для получения последней стабильной версии MuseScore
!apt-get update

# Установка программы MuseScore для отображения нот
!apt-get install musescore  # Генерация изображений нот

# Установка Xvfb для запуска MuseScore в виртуальном фреймбуфере
!apt-get install xvfb  # Виртуальный фреймбуфер для Colab

from music21 import environment, converter, instrument, note, chord, stream
import warnings
import numpy as np
import os
from collections import Counter
import matplotlib.pyplot as plt
from collections import Counter
import tensorflow
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, BatchNormalization
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping
import random

# Отключение предупреждений
warnings.filterwarnings("ignore")

"""# Константы"""

np.random.seed(42)
DATASET_PATH = "./dataset/"
length = 40
EPOCHS = 150  # Количество эпох
BATCH_SIZE = 64  # Размер батча

"""# Настройка окружения для music21"""

# настраиваем окружение в соответствии с документацией
us = environment.UserSettings()
us['musescoreDirectPNGPath'] = '/usr/bin/mscore'  # Путь к MuseScore
us['directoryScratch'] = '/tmp'  # Временная директория для хранения

"""# Загрузка и анализ датасета"""

!wget https://storage.yandexcloud.net/academy.ai/classical-music-midi.zip
!unzip -qo "classical-music-midi.zip" -d ./dataset

!dir ./dataset

CLASS_LIST = os.listdir(DATASET_PATH)

"""## Количество нот в датасете"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# # Словарь для хранения нот каждого композитора и их уникальных значений
# composer_notes = {}  # Словарь для уникальных нот
# composer_all_notes = {}  # Словарь для хранения всех нот каждого композитора
# 
# # Извлечение уникальных нот для каждого композитора
# for composer in CLASS_LIST:
#     filepath = os.path.join(DATASET_PATH, composer)
#     composer_midis = []
#     for filename in os.listdir(filepath):
#         if filename.endswith(".mid"):
#             midi_path = os.path.join(filepath, filename)
#             midi = converter.parse(midi_path)
#             composer_midis.append(midi)
#     # Извлечение уникальных нот и аккордов
#     notes = set()  # Используем множество для хранения уникальных значений
#     for midi in composer_midis:
#         parts = instrument.partitionByInstrument(midi)
#         for part in parts.parts:
#             notes_to_parse = part.recurse()
#             for element in notes_to_parse:
#                 if isinstance(element, note.Note):
#                     notes.add(str(element.pitch))
#                 elif isinstance(element, chord.Chord):
#                     notes.add(".".join(str(n) for n in element.normalOrder))
#     composer_notes[composer] = notes

unique_notes_counts = {composer: len(notes) for composer, notes in composer_notes.items()}
all_notes_counts = {composer: len(notes) for composer, notes in composer_all_notes.items()}

plt.figure(figsize=(10, 6), facecolor='#97BACB')
plt.bar(unique_notes_counts.keys(), unique_notes_counts.values(), color='lightgreen')
plt.xlabel('Композиторы', fontsize=14)
plt.ylabel('Количество уникальных нот', fontsize=14)
plt.title('Количество уникальных нот для каждого композитора', fontsize=16)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6), facecolor='#97BACB')
plt.bar(all_notes_counts.keys(), all_notes_counts.values(), color='skyblue')
plt.xlabel('Композиторы', fontsize=14)
plt.ylabel('Общее количество нот', fontsize=14)
plt.title('Общее количество нот для каждого композитора', fontsize=16)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

del composer_notes, composer_all_notes

"""Определим список композиторов, исходя из полученных данных"""

selected_composers = ['Ravel', 'Schubert', 'Liszt', 'Mozart', 'Beethoven']

"""## Анализ отрывка композиции"""

# Вывод первых 100 нот для композитора Mozart
mozart_filepath = os.path.join(DATASET_PATH, 'Mozart')
mozart_files = [f for f in os.listdir(mozart_filepath) if f.endswith('.mid')]
if mozart_files:
    first_mozart_piece_path = os.path.join(mozart_filepath, mozart_files[0])
    mozart_score = converter.parse(first_mozart_piece_path)
    notes = []
    for element in mozart_score.flat.notes[:100]:  # Извлекаем первые 100 нот
        if isinstance(element, note.Note):
            notes.append(str(element.pitch))
        elif isinstance(element, chord.Chord):
            notes.append(".".join(str(n) for n in element.normalOrder))
    print("Первые 100 нот произведения Моцарта:")
    print(notes)

notes_stream = stream.Stream()
for element in mozart_score.flat.notes[:100]:
    notes_stream.append(element)
notes_stream.show()  # Показываем нотный стан с первыми 100 нотами произведения Моцарта

notes_stream.show('midi')

"""## Всего нот"""

all_midis = []
for composer in selected_composers:
    filepath = os.path.join(DATASET_PATH, composer)
    for filename in os.listdir(filepath):
        if filename.endswith(".mid"):
            midi_path = os.path.join(filepath, filename)
            midi = converter.parse(midi_path)  # Чтение и парсинг MIDI-файлов в Stream-объект библиотеки music21
            all_midis.append(midi)

"""Функция для преобразования потока Stream midi-файлов в список нот"""

def getNotes(files):
    notes = []
    for midi in files:
        songs = instrument.partitionByInstrument(midi)
        for part in songs.parts:
            notes_to_parse = part.recurse()
            for element in notes_to_parse:
                if isinstance(element, note.Note):
                    notes.append(str(element.pitch))
                elif isinstance(element, chord.Chord):
                    notes.append(".".join(str(n) for n in element.normalOrder))
    return notes

Corpus = getNotes(all_midis)
print("Всего нот в корпусе midi-файлах:", len(Corpus))

"""## Уникальные ноты"""

count_num = Counter(Corpus)
print("Общее число уникальных нот в корпусе:", len(count_num))

Notes = list(count_num.keys())
Recurrence = list(count_num.values())

def Average(rec):
    return sum(rec) / len(rec)

print('Средняя повторяемость ноты:', Average(Recurrence))
print('Наиболее часто встречаемые ноты:', max(Recurrence), 'раз')
print('Наиболее редкие ноты:', min(Recurrence), 'раз')

plt.figure(figsize=(18, 3), facecolor='#97BACB')
bins = np.arange(0,(max(Recurrence)), 50)
plt.hist(Recurrence, bins=bins, color='#97BACB')
plt.axvline(x=100, color='#DBACC1') # отсечка по встречаемости в 100 раз
plt.title('Распределение нот в корпусе')
plt.xlabel('Частота встречаемости ноты в корпусе')
plt.ylabel('Число нот')
plt.show()

# Получение списка редких нот
rare_note = []
for index, (key, value) in enumerate(count_num.items()):
    if value < 100:
        m =  key
        rare_note.append(m)

print("Общее число нот, которые повторяются менее 100 раз:", len(rare_note))

for element in Corpus:
    if element in rare_note:
        Corpus.remove(element)

print("Длина корпуса после исключения редких нот:", len(Corpus))

"""# Предобработка датасета"""

# Сохраняем все уникальные значения корпуса
symb = sorted(list(set(Corpus)))

L_corpus = len(Corpus) # длина корпуса
L_symb = len(symb) # число уникальных элементов корпуса

# Создание словаря для доступа к словарному запасу из индексов и наоборот
mapping = dict((c, i) for i, c in enumerate(symb))
reverse_mapping = dict((i, c) for i, c in enumerate(symb))

print("Общее число символов:", L_corpus)
print("Число уникальных символов:", L_symb)

"""## Разбиение корпуса"""

# входные последовательности
features = []

# целевые последовательности
targets = []

# цикл разбиения корпуса
for i in range(0, L_corpus - length, 1):
    feature = Corpus[i:i + length]
    target = Corpus[i + length]
    features.append([mapping[j] for j in feature])
    targets.append(mapping[target])


L_datapoints = len(targets)
print("Общее количество последовательностей в корпусе:", L_datapoints)

"""## Нормализация"""

# изменение размера и нормализация входных данных
X = (np.reshape(features, (L_datapoints, length, 1)))/ float(L_symb)

# one-hot encode для целевых выходных данных
y = tensorflow.keras.utils.to_categorical(targets)

print(f'Форма входных данных: {X.shape}')
print(f'Форма выходных данных: {y.shape}')

"""## Создание выборки"""

X_train, X_seed, y_train, y_seed = train_test_split(X, y, test_size=0.2, random_state=42)

"""# Архитектура модели"""

model = Sequential()

model.add(LSTM(256, input_shape=X.shape[1:], return_sequences=True))
model.add(Dropout(0.1))
model.add(LSTM(128))
model.add(Dense(128))
model.add(Dropout(0.1))
model.add(Dense(y.shape[1], activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer='Adam', metrics=['acc'])

model.summary()

"""## Callbacks"""

# Определение колбэков
checkpoint = ModelCheckpoint('best_model.keras', monitor='loss', verbose=1, save_best_only=True, mode='min')
early_stopping = EarlyStopping(monitor='loss', patience=10, verbose=1, mode='min')
callbacks_list = [checkpoint, early_stopping]

"""## Обучение"""

# Обучение модели
history = model.fit(X_train, y_train, epochs=EPOCHS, batch_size=BATCH_SIZE, callbacks=callbacks_list)

"""## Графики обучения"""

plt.plot(history.epoch, history.history['acc'], 'r', label='Точность на обучающей выборке')
plt.title('График точности на обучающей выборке')
plt.legend()
plt.figure()
plt.plot(history.epoch, history.history['loss'], 'b', label='Потери на обучающей выборке')
plt.title('График потерь на обучающей выборке')
plt.legend()
plt.show()

"""Уровень обучения довольно низкий, но модель ещё способна учиться

# Генерация произведения
"""

def generate_music(model, length=100):
    # Выбор случайной начальной последовательности из обучающего набора
    start_index = random.randint(0, len(X_seed) - 1)
    pattern = X_seed[start_index]

    # Генерация нот
    generated_notes = []
    for _ in range(length):
        # Добавление измерения для предсказания
        prediction_input = np.reshape(pattern, (1, pattern.shape[0], 1))
        prediction = model.predict(prediction_input, verbose=0)

        # Определение следующей ноты на основе наибольшей вероятности
        index = np.argmax(prediction)
        result = reverse_mapping[index]
        generated_notes.append(result)

        # Обновление входного паттерна
        pattern = np.append(pattern[1:], [[index]], axis=0)

    return generated_notes
    for item in generated_notes:
        if '.' in item:
            chord_notes = [int(x) for x in item.split('.')]
            new_chord = chord.Chord(chord_notes)
            stream_output.append(new_chord)
        else:
            new_note = note.Note(item)
            stream_output.append(new_note)

# Генерация музыкальной композиции
generated_notes = generate_music(model, length=100)

# Восстановление нотной последовательности и воспроизведение
stream_output = stream.Stream()
for item in generated_notes:
    if '.' in item:
        chord_notes = [int(x) for x in item.split('.')]
        new_chord = chord.Chord(chord_notes)
        stream_output.append(new_chord)
    else:
        new_note = note.Note(item)
        stream_output.append(new_note)

# Отображение нотного стана
stream_output.show()

# Воспроизведение сгенерированной последовательности
stream_output.show('midi')